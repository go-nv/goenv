// Generate embedded_lifecycle.go with Go version lifecycle data from endoflife.date API
// This program is run during build/release to embed the latest lifecycle data
//
// Usage: make generate-embedded
// Or: go run scripts/generate_embedded_lifecycle/main.go

package main

import (
	"fmt"
	"os"
	"sort"
	"time"

	"github.com/go-nv/goenv/internal/utils"
)

const (
	apiURL     = "https://endoflife.date/api/go.json"
	outputFile = "internal/lifecycle/embedded_lifecycle.go"
)

// EOLData represents lifecycle information from endoflife.date API
type EOLData struct {
	Cycle             string      `json:"cycle"`
	ReleaseDate       string      `json:"releaseDate"`
	EOL               interface{} `json:"eol"` // Can be string date or bool false
	Latest            string      `json:"latest"`
	LatestReleaseDate string      `json:"latestReleaseDate"`
	LTS               bool        `json:"lts"`
}

func main() {
	fmt.Printf("Fetching Go lifecycle data from %s...\n", apiURL)

	// Fetch lifecycle data from API
	lifecycleData, err := fetchLifecycleData()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error fetching lifecycle data: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Found %d versions\n", len(lifecycleData))

	// Generate the Go source file
	if err := generateSourceFile(lifecycleData); err != nil {
		fmt.Fprintf(os.Stderr, "Error generating file: %v\n", err)
		os.Exit(1)
	}

	// Get file info
	size := utils.GetFileSize(outputFile)
	fmt.Printf("âœ… Generated %s with %d versions (%d KB)\n",
		outputFile, len(lifecycleData), size/1024)
}

func fetchLifecycleData() ([]EOLData, error) {
	var data []EOLData
	if err := utils.FetchJSONWithTimeout(apiURL, &data, 30*time.Second); err != nil {
		return nil, fmt.Errorf("failed to fetch lifecycle data: %w", err)
	}
	return data, nil
}

func generateSourceFile(data []EOLData) error {
	f, err := os.Create(outputFile)
	if err != nil {
		return fmt.Errorf("failed to create file: %w", err)
	}
	defer f.Close()

	// Sort by cycle version (descending)
	sort.Slice(data, func(i, j int) bool {
		return data[i].Cycle > data[j].Cycle
	})

	// Write header
	fmt.Fprintf(f, "// Code generated by scripts/generate_embedded_lifecycle/main.go; DO NOT EDIT.\n")
	fmt.Fprintf(f, "// This file is generated from the endoflife.date API at build time.\n")
	fmt.Fprintf(f, "// To regenerate: make generate-embedded\n")
	fmt.Fprintf(f, "//\n")
	fmt.Fprintf(f, "// Generated from: %s\n", apiURL)
	fmt.Fprintf(f, "// Generated at: %s\n\n", time.Now().UTC().Format(time.RFC3339))
	fmt.Fprintf(f, "package lifecycle\n\n")
	fmt.Fprintf(f, "import \"time\"\n\n")
	fmt.Fprintf(f, "// EmbeddedLifecycleData contains fallback lifecycle information for Go versions\n")
	fmt.Fprintf(f, "// Generated at build time from the endoflife.date API\n")
	fmt.Fprintf(f, "// Used as last resort when both network and cache are unavailable\n")
	fmt.Fprintf(f, "var EmbeddedLifecycleData = map[string]VersionInfo{\n")

	// Write each version
	for _, item := range data {
		// Parse EOL date
		var eolDateStr string
		switch v := item.EOL.(type) {
		case string:
			eolDateStr = v
		case bool:
			if !v {
				// EOL is false, meaning still supported - use far future date
				eolDateStr = "2099-12-31"
			}
		}

		// Skip if we don't have valid data
		if item.ReleaseDate == "" || eolDateStr == "" {
			continue
		}

		fmt.Fprintf(f, "\t%q: {\n", item.Cycle)
		fmt.Fprintf(f, "\t\tVersion:      %q,\n", item.Cycle)
		fmt.Fprintf(f, "\t\tReleaseDate:  parseDate(%q),\n", item.ReleaseDate)
		fmt.Fprintf(f, "\t\tEOLDate:      parseDate(%q),\n", eolDateStr)
		fmt.Fprintf(f, "\t\tStatus:       StatusUnknown, // Calculated dynamically at runtime\n")
		fmt.Fprintf(f, "\t\tRecommended:  \"\", // Calculated dynamically at runtime\n")
		fmt.Fprintf(f, "\t\tSecurityOnly: false, // Determined at runtime\n")
		fmt.Fprintf(f, "\t},\n")
	}

	// Close map
	fmt.Fprintf(f, "}\n\n")
	fmt.Fprintf(f, "// EmbeddedGeneratedAt is the timestamp when this file was generated\n")
	fmt.Fprintf(f, "const EmbeddedGeneratedAt = %q\n", time.Now().UTC().Format(time.RFC3339))

	return nil
}

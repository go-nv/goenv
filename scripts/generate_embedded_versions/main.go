// Generate embedded_versions.go with current Go releases from the official API
// This program is run during build/release to embed the latest version data
//
// Usage: make generate-embedded
// Or: go run scripts/generate_embedded_versions/main.go

package main

import (
	"fmt"
	"os"
	"time"

	"github.com/go-nv/goenv/internal/utils"
)

const (
	apiURL     = "https://go.dev/dl/?mode=json&include=all"
	outputFile = "internal/version/embedded_versions.go"
)

type GoRelease struct {
	Version string   `json:"version"`
	Stable  bool     `json:"stable"`
	Files   []GoFile `json:"files"`
}

type GoFile struct {
	Filename string `json:"filename"`
	OS       string `json:"os"`
	Arch     string `json:"arch"`
	SHA256   string `json:"sha256"`
	Size     int64  `json:"size"`
	Kind     string `json:"kind"`
}

func main() {
	fmt.Printf("Fetching Go releases from %s...\n", apiURL)

	// Fetch releases from API
	releases, err := fetchReleases()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error fetching releases: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Found %d versions\n", len(releases))

	// Generate the Go source file
	if err := generateSourceFile(releases); err != nil {
		fmt.Fprintf(os.Stderr, "Error generating file: %v\n", err)
		os.Exit(1)
	}

	// Get file info
	size := utils.GetFileSize(outputFile)
	fmt.Printf("âœ… Generated %s with %d versions (%d KB)\n",
		outputFile, len(releases), size/1024)
}

func fetchReleases() ([]GoRelease, error) {
	var releases []GoRelease
	if err := utils.FetchJSONWithTimeout(apiURL, &releases, 30*time.Second); err != nil {
		return nil, fmt.Errorf("failed to fetch releases: %w", err)
	}
	return releases, nil
}

func generateSourceFile(releases []GoRelease) error {
	f, err := os.Create(outputFile)
	if err != nil {
		return fmt.Errorf("failed to create file: %w", err)
	}
	defer f.Close()

	// Write header
	fmt.Fprintf(f, "// Code generated by scripts/generate_embedded_versions/main.go; DO NOT EDIT.\n")
	fmt.Fprintf(f, "// This file is generated from the official Go releases API at build time.\n")
	fmt.Fprintf(f, "// To regenerate: make generate-embedded\n")
	fmt.Fprintf(f, "//\n")
	fmt.Fprintf(f, "// Generated from: %s\n", apiURL)
	fmt.Fprintf(f, "// Generated at: %s\n\n", time.Now().UTC().Format(time.RFC3339))
	fmt.Fprintf(f, "package version\n\n")
	fmt.Fprintf(f, "// EmbeddedVersions contains a fallback list of Go versions\n")
	fmt.Fprintf(f, "// Generated at build time from the official Go releases API\n")
	fmt.Fprintf(f, "// Used as last resort when both network and cache are unavailable\n")
	fmt.Fprintf(f, "var EmbeddedVersions = []GoRelease{\n")

	// Major platforms to include (keep file size reasonable)
	majorPlatforms := map[string]bool{
		"darwin":  true,
		"linux":   true,
		"windows": true,
		"freebsd": true,
	}

	// Write each release
	for _, release := range releases {
		// Filter to only archive files for major platforms
		var files []GoFile
		for _, file := range release.Files {
			if file.Kind == "archive" && majorPlatforms[file.OS] {
				files = append(files, file)
			}
		}

		// Skip if no relevant files
		if len(files) == 0 {
			continue
		}

		fmt.Fprintf(f, "\t{\n")
		fmt.Fprintf(f, "\t\tVersion: %q,\n", release.Version)
		fmt.Fprintf(f, "\t\tStable:  %t,\n", release.Stable)
		fmt.Fprintf(f, "\t\tFiles: []GoFile{\n")

		for _, file := range files {
			fmt.Fprintf(f, "\t\t\t{Filename: %q, OS: %q, Arch: %q, Kind: %q, SHA256: %q, Size: %d},\n",
				file.Filename, file.OS, file.Arch, file.Kind, file.SHA256, file.Size)
		}

		fmt.Fprintf(f, "\t\t},\n")
		fmt.Fprintf(f, "\t},\n")
	}

	// Close array and add metadata
	fmt.Fprintf(f, "}\n\n")
	fmt.Fprintf(f, "// GeneratedAt is the timestamp when this file was generated\n")
	fmt.Fprintf(f, "const GeneratedAt = %q\n\n", time.Now().UTC().Format(time.RFC3339))
	fmt.Fprintf(f, "// TotalEmbeddedVersions is the count of embedded versions\n")
	fmt.Fprintf(f, "const TotalEmbeddedVersions = %d\n", len(releases))

	return nil
}

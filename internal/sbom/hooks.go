package sbom

import (
	"bytes"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
)

// HookManager manages Git hooks for SBOM generation
type HookManager struct {
	RepoRoot  string
	HooksDir  string
	GoenvPath string
}

// HookConfig defines configuration for hook installation
type HookConfig struct {
	// AutoGenerate enables automatic SBOM generation
	AutoGenerate bool
	// FailOnError prevents commits if SBOM generation fails
	FailOnError bool
	// OutputPath specifies where to generate the SBOM
	OutputPath string
	// Format specifies SBOM format (cyclonedx, spdx, syft)
	Format string
	// Quiet suppresses hook output
	Quiet bool
}

// DefaultHookConfig returns default hook configuration
func DefaultHookConfig() HookConfig {
	return HookConfig{
		AutoGenerate: true,
		FailOnError:  true,
		OutputPath:   "sbom.json",
		Format:       "cyclonedx",
		Quiet:        false,
	}
}

// NewHookManager creates a new hook manager
func NewHookManager(repoPath string) (*HookManager, error) {
	return NewHookManagerWithGoenv(repoPath, "")
}

// NewHookManagerWithGoenv creates a new hook manager with a specified goenv path
// If goenvPath is empty, it will attempt to locate it automatically
func NewHookManagerWithGoenv(repoPath, goenvPath string) (*HookManager, error) {
	if repoPath == "" {
		cwd, err := os.Getwd()
		if err != nil {
			return nil, fmt.Errorf("failed to get current directory: %w", err)
		}
		repoPath = cwd
	}

	// Find Git root
	gitRoot, err := findGitRoot(repoPath)
	if err != nil {
		return nil, fmt.Errorf("not a git repository: %w", err)
	}

	hooksDir := filepath.Join(gitRoot, ".git", "hooks")
	if _, err := os.Stat(hooksDir); err != nil {
		return nil, fmt.Errorf("git hooks directory not found: %w", err)
	}

	// Find goenv executable if not provided
	if goenvPath == "" {
		goenvPath, err = findGoenvExecutable()
		if err != nil {
			return nil, fmt.Errorf("failed to locate goenv: %w", err)
		}
	}

	return &HookManager{
		RepoRoot:  gitRoot,
		HooksDir:  hooksDir,
		GoenvPath: goenvPath,
	}, nil
}

// InstallHook installs the pre-commit hook
func (hm *HookManager) InstallHook(config HookConfig) error {
	hookPath := filepath.Join(hm.HooksDir, "pre-commit")

	// Check if hook already exists
	existingHook, err := os.ReadFile(hookPath)
	if err == nil {
		// Hook exists - check if it's managed by goenv
		if !strings.Contains(string(existingHook), "# goenv-sbom-hook") {
			return fmt.Errorf("pre-commit hook already exists and is not managed by goenv\nUse --force to overwrite or manually integrate with existing hook")
		}
	}

	// Generate hook script
	hookScript := hm.generateHookScript(config)

	// Write hook file
	if err := os.WriteFile(hookPath, []byte(hookScript), 0755); err != nil {
		return fmt.Errorf("failed to write hook file: %w", err)
	}

	return nil
}

// UninstallHook removes the pre-commit hook if it's managed by goenv
func (hm *HookManager) UninstallHook() error {
	hookPath := filepath.Join(hm.HooksDir, "pre-commit")

	// Check if hook exists
	existingHook, err := os.ReadFile(hookPath)
	if os.IsNotExist(err) {
		return fmt.Errorf("pre-commit hook not found")
	}
	if err != nil {
		return fmt.Errorf("failed to read hook file: %w", err)
	}

	// Check if it's managed by goenv
	if !strings.Contains(string(existingHook), "# goenv-sbom-hook") {
		return fmt.Errorf("pre-commit hook is not managed by goenv")
	}

	// Remove hook file
	if err := os.Remove(hookPath); err != nil {
		return fmt.Errorf("failed to remove hook file: %w", err)
	}

	return nil
}

// IsHookInstalled checks if the goenv SBOM hook is installed
func (hm *HookManager) IsHookInstalled() (bool, error) {
	hookPath := filepath.Join(hm.HooksDir, "pre-commit")

	data, err := os.ReadFile(hookPath)
	if os.IsNotExist(err) {
		return false, nil
	}
	if err != nil {
		return false, err
	}

	return strings.Contains(string(data), "# goenv-sbom-hook"), nil
}

// generateHookScript generates the pre-commit hook script
func (hm *HookManager) generateHookScript(config HookConfig) string {
	var buf bytes.Buffer

	buf.WriteString("#!/bin/sh\n")
	buf.WriteString("# goenv-sbom-hook\n")
	buf.WriteString("# Auto-generated by goenv - DO NOT EDIT MANUALLY\n")
	buf.WriteString("#\n")
	buf.WriteString("# This hook automatically generates SBOM when go.mod or go.sum changes\n")
	buf.WriteString("\n")

	// Add quiet mode handling
	if config.Quiet {
		buf.WriteString("GOENV_QUIET=1\n")
	} else {
		buf.WriteString("GOENV_QUIET=0\n")
	}
	buf.WriteString("\n")

	// Check for go.mod or go.sum changes
	buf.WriteString("# Check if go.mod or go.sum changed\n")
	buf.WriteString("if git diff --cached --name-only | grep -qE '^go\\.(mod|sum)$'; then\n")

	if !config.Quiet {
		buf.WriteString("    echo \"üîç Detected changes in go.mod or go.sum\"\n")
		buf.WriteString("    echo \"üì¶ Generating SBOM...\"\n")
	}
	buf.WriteString("\n")

	// Generate SBOM command
	outputPath := config.OutputPath
	if !filepath.IsAbs(outputPath) {
		outputPath = filepath.Join(hm.RepoRoot, outputPath)
	}

	sbomCmd := fmt.Sprintf("    %s sbom generate --output %s --format %s",
		hm.GoenvPath, outputPath, config.Format)

	if config.Quiet {
		sbomCmd += " --quiet"
	}

	buf.WriteString(sbomCmd + "\n")
	buf.WriteString("    SBOM_EXIT_CODE=$?\n")
	buf.WriteString("\n")

	// Handle generation result
	if config.FailOnError {
		buf.WriteString("    if [ $SBOM_EXIT_CODE -ne 0 ]; then\n")
		buf.WriteString("        echo \"‚ùå SBOM generation failed\"\n")
		buf.WriteString("        echo \"Fix the errors above or run: goenv sbom hooks uninstall\"\n")
		buf.WriteString("        exit 1\n")
		buf.WriteString("    fi\n")
		buf.WriteString("\n")
	} else {
		buf.WriteString("    if [ $SBOM_EXIT_CODE -ne 0 ]; then\n")
		buf.WriteString("        echo \"‚ö†Ô∏è  SBOM generation failed (continuing anyway)\"\n")
		buf.WriteString("    fi\n")
		buf.WriteString("\n")
	}

	// Stage the generated SBOM
	relOutputPath := config.OutputPath
	if filepath.IsAbs(config.OutputPath) {
		var err error
		relOutputPath, err = filepath.Rel(hm.RepoRoot, config.OutputPath)
		if err != nil {
			relOutputPath = config.OutputPath
		}
	}

	if !config.Quiet {
		buf.WriteString(fmt.Sprintf("    echo \"‚úÖ SBOM generated: %s\"\n", relOutputPath))
		buf.WriteString("    echo \"üìù Staging SBOM for commit...\"\n")
	}
	buf.WriteString(fmt.Sprintf("    git add %s\n", relOutputPath))
	buf.WriteString("fi\n")
	buf.WriteString("\n")
	buf.WriteString("exit 0\n")

	return buf.String()
}

// findGitRoot finds the root directory of the Git repository
func findGitRoot(startPath string) (string, error) {
	absPath, err := filepath.Abs(startPath)
	if err != nil {
		return "", err
	}

	current := absPath
	for {
		gitDir := filepath.Join(current, ".git")
		if info, err := os.Stat(gitDir); err == nil && info.IsDir() {
			return current, nil
		}

		parent := filepath.Dir(current)
		if parent == current {
			return "", fmt.Errorf("not a git repository")
		}
		current = parent
	}
}

// findGoenvExecutable locates the goenv executable
func findGoenvExecutable() (string, error) {
	// Try to find in PATH
	if path, err := exec.LookPath("goenv"); err == nil {
		absPath, err := filepath.Abs(path)
		if err == nil {
			return absPath, nil
		}
		return path, nil
	}

	// Try current executable (when running from build)
	if exe, err := os.Executable(); err == nil {
		if strings.Contains(filepath.Base(exe), "goenv") {
			return exe, nil
		}
	}

	return "", fmt.Errorf("goenv executable not found in PATH")
}

// GetHookStatus returns status information about the hook
func (hm *HookManager) GetHookStatus() (map[string]interface{}, error) {
	status := make(map[string]interface{})

	hookPath := filepath.Join(hm.HooksDir, "pre-commit")
	status["hook_path"] = hookPath
	status["repo_root"] = hm.RepoRoot
	status["goenv_path"] = hm.GoenvPath

	installed, err := hm.IsHookInstalled()
	if err != nil {
		return nil, err
	}
	status["installed"] = installed

	if installed {
		data, err := os.ReadFile(hookPath)
		if err == nil {
			status["hook_content"] = string(data)
		}
	}

	return status, nil
}

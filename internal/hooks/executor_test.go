package hooks

import (
	"os"
	"path/filepath"
	"strings"
	"testing"
)

func TestNewExecutor(t *testing.T) {
	config := &Config{
		Version:           1,
		Enabled:           true,
		AcknowledgedRisks: true,
		Settings: Settings{
			Timeout:    "5s",
			MaxActions: 10,
		},
	}

	executor := NewExecutor(config)
	if executor == nil {
		t.Fatal("NewExecutor() returned nil")
	}
	if executor.config != config {
		t.Error("NewExecutor() config not set correctly")
	}
	if executor.registry == nil {
		t.Error("NewExecutor() registry is nil")
	}
}

func TestExecutorExecute_Disabled(t *testing.T) {
	config := &Config{
		Version:           1,
		Enabled:           false, // Disabled
		AcknowledgedRisks: false,
	}

	executor := NewExecutor(config)
	err := executor.Execute(PreInstall, map[string]string{"version": "1.21.0"})
	if err != nil {
		t.Errorf("Execute() with disabled hooks returned error: %v", err)
	}
}

func TestExecutorExecute_NoHooks(t *testing.T) {
	config := &Config{
		Version:           1,
		Enabled:           true,
		AcknowledgedRisks: true,
		Settings: Settings{
			Timeout:    "5s",
			MaxActions: 10,
		},
		Hooks: map[string][]Action{}, // No hooks configured
	}

	executor := NewExecutor(config)
	err := executor.Execute(PreInstall, map[string]string{"version": "1.21.0"})
	if err != nil {
		t.Errorf("Execute() with no hooks returned error: %v", err)
	}
}

func TestExecutorExecute_LogToFile(t *testing.T) {
	tmpDir := t.TempDir()
	logFile := filepath.Join(tmpDir, "test.log")

	config := &Config{
		Version:           1,
		Enabled:           true,
		AcknowledgedRisks: true,
		Settings: Settings{
			Timeout:         "5s",
			MaxActions:      10,
			ContinueOnError: true,
		},
		Hooks: map[string][]Action{
			"pre_install": {
				{
					Action: "log_to_file",
					Params: map[string]interface{}{
						"file":   logFile,
						"format": "Installing {version} at {timestamp}",
					},
				},
			},
		},
	}

	executor := NewExecutor(config)
	vars := map[string]string{
		"version":   "1.21.0",
		"hook":      "pre_install",
		"timestamp": "2024-01-01T00:00:00Z",
	}

	err := executor.Execute(PreInstall, vars)
	if err != nil {
		t.Fatalf("Execute() unexpected error: %v", err)
	}

	// Verify log file was created and contains interpolated values
	content, err := os.ReadFile(logFile)
	if err != nil {
		t.Fatalf("Failed to read log file: %v", err)
	}

	contentStr := string(content)
	if !strings.Contains(contentStr, "Installing 1.21.0") {
		t.Errorf("Log file doesn't contain interpolated version, got: %s", contentStr)
	}
	// Note: timestamp will be auto-generated by log_to_file action, not from template
	if !strings.Contains(contentStr, "at") {
		t.Errorf("Log file doesn't contain expected format, got: %s", contentStr)
	}
}

func TestExecutorExecute_UnknownAction(t *testing.T) {
	config := &Config{
		Version:           1,
		Enabled:           true,
		AcknowledgedRisks: true,
		Settings: Settings{
			Timeout:         "5s",
			MaxActions:      10,
			ContinueOnError: false,
		},
		Hooks: map[string][]Action{
			"pre_install": {
				{
					Action: "unknown_action",
					Params: map[string]interface{}{},
				},
			},
		},
	}

	executor := NewExecutor(config)
	err := executor.Execute(PreInstall, map[string]string{})
	if err == nil {
		t.Error("Execute() with unknown action expected error, got nil")
	}
	if !strings.Contains(err.Error(), "unknown action") {
		t.Errorf("Execute() error message = %v, want to contain 'unknown action'", err)
	}
}

func TestExecutorExecute_ContinueOnError(t *testing.T) {
	tmpDir := t.TempDir()
	logFile := filepath.Join(tmpDir, "test.log")

	config := &Config{
		Version:           1,
		Enabled:           true,
		AcknowledgedRisks: true,
		Settings: Settings{
			Timeout:         "5s",
			MaxActions:      10,
			ContinueOnError: true,
		},
		Hooks: map[string][]Action{
			"pre_install": {
				{
					Action: "log_to_file",
					Params: map[string]interface{}{
						// Missing required 'file' parameter - will fail
						"format": "test",
					},
				},
				{
					Action: "log_to_file",
					Params: map[string]interface{}{
						"file":   logFile,
						"format": "Second action executed",
					},
				},
			},
		},
	}

	executor := NewExecutor(config)
	err := executor.Execute(PreInstall, map[string]string{})

	// Should NOT error because continue_on_error is true
	if err != nil {
		t.Errorf("Execute() with continue_on_error=true returned error: %v", err)
	}

	// Verify second action still executed
	content, err := os.ReadFile(logFile)
	if err != nil {
		t.Fatalf("Failed to read log file: %v", err)
	}
	if !strings.Contains(string(content), "Second action executed") {
		t.Error("Second action was not executed despite continue_on_error=true")
	}
}

func TestExecutorExecute_StopOnError(t *testing.T) {
	tmpDir := t.TempDir()
	logFile := filepath.Join(tmpDir, "test.log")

	config := &Config{
		Version:           1,
		Enabled:           true,
		AcknowledgedRisks: true,
		Settings: Settings{
			Timeout:         "5s",
			MaxActions:      10,
			ContinueOnError: false, // Stop on first error
		},
		Hooks: map[string][]Action{
			"pre_install": {
				{
					Action: "log_to_file",
					Params: map[string]interface{}{
						// Missing required 'file' parameter - will fail
						"format": "test",
					},
				},
				{
					Action: "log_to_file",
					Params: map[string]interface{}{
						"file":   logFile,
						"format": "This should not execute",
					},
				},
			},
		},
	}

	executor := NewExecutor(config)
	err := executor.Execute(PreInstall, map[string]string{})

	// Should error because continue_on_error is false
	if err == nil {
		t.Error("Execute() with continue_on_error=false expected error, got nil")
	}

	// Verify second action did NOT execute
	if _, err := os.Stat(logFile); err == nil {
		t.Error("Second action was executed despite continue_on_error=false")
	}
}

func TestExecutorTestExecute_Disabled(t *testing.T) {
	config := &Config{
		Version:           1,
		Enabled:           false,
		AcknowledgedRisks: false,
	}

	executor := NewExecutor(config)
	results, err := executor.TestExecute(PreInstall, map[string]string{"version": "1.21.0"})
	if err != nil {
		t.Errorf("TestExecute() unexpected error: %v", err)
	}
	if len(results) != 1 || !strings.Contains(results[0], "disabled") {
		t.Errorf("TestExecute() with disabled hooks = %v, want disabled message", results)
	}
}

func TestExecutorTestExecute_NoHooks(t *testing.T) {
	config := &Config{
		Version:           1,
		Enabled:           true,
		AcknowledgedRisks: true,
		Settings: Settings{
			Timeout:    "5s",
			MaxActions: 10,
		},
		Hooks: map[string][]Action{},
	}

	executor := NewExecutor(config)
	results, err := executor.TestExecute(PreInstall, map[string]string{})
	if err != nil {
		t.Errorf("TestExecute() unexpected error: %v", err)
	}
	if len(results) != 1 || !strings.Contains(results[0], "No hooks configured") {
		t.Errorf("TestExecute() with no hooks = %v, want no hooks message", results)
	}
}

func TestExecutorTestExecute_ValidActions(t *testing.T) {
	config := &Config{
		Version:           1,
		Enabled:           true,
		AcknowledgedRisks: true,
		Settings: Settings{
			Timeout:    "5s",
			MaxActions: 10,
		},
		Hooks: map[string][]Action{
			"pre_install": {
				{
					Action: "log_to_file",
					Params: map[string]interface{}{
						"file":   "/tmp/test.log",
						"format": "Installing {version}",
					},
				},
			},
		},
	}

	executor := NewExecutor(config)
	results, err := executor.TestExecute(PreInstall, map[string]string{"version": "1.21.0"})
	if err != nil {
		t.Errorf("TestExecute() unexpected error: %v", err)
	}

	// Should show success and interpolated values
	if len(results) == 0 {
		t.Fatal("TestExecute() returned no results")
	}

	foundSuccess := false
	foundInterpolation := false
	for _, result := range results {
		if strings.Contains(result, "✓") || strings.Contains(result, "log_to_file") {
			foundSuccess = true
		}
		if strings.Contains(result, "Installing 1.21.0") {
			foundInterpolation = true
		}
	}

	if !foundSuccess {
		t.Errorf("TestExecute() results missing success indicator: %v", results)
	}
	if !foundInterpolation {
		t.Errorf("TestExecute() results missing interpolated values: %v", results)
	}
}

func TestExecutorTestExecute_InvalidAction(t *testing.T) {
	config := &Config{
		Version:           1,
		Enabled:           true,
		AcknowledgedRisks: true,
		Settings: Settings{
			Timeout:    "5s",
			MaxActions: 10,
		},
		Hooks: map[string][]Action{
			"pre_install": {
				{
					Action: "unknown_action",
					Params: map[string]interface{}{},
				},
			},
		},
	}

	executor := NewExecutor(config)
	results, err := executor.TestExecute(PreInstall, map[string]string{})
	if err != nil {
		t.Errorf("TestExecute() unexpected error: %v", err)
	}

	// Should show failure for unknown action
	foundError := false
	for _, result := range results {
		if strings.Contains(result, "✗") || strings.Contains(result, "unknown") {
			foundError = true
			break
		}
	}
	if !foundError {
		t.Errorf("TestExecute() with unknown action should show error, got: %v", results)
	}
}

func TestTemplateInterpolation(t *testing.T) {
	tests := []struct {
		name     string
		input    string
		vars     map[string]string
		expected string
	}{
		{
			name:     "Single variable",
			input:    "Installing {version}",
			vars:     map[string]string{"version": "1.21.0"},
			expected: "Installing 1.21.0",
		},
		{
			name:     "Multiple variables",
			input:    "{hook} for {version} at {timestamp}",
			vars:     map[string]string{"hook": "pre_install", "version": "1.21.0", "timestamp": "2024-01-01"},
			expected: "pre_install for 1.21.0 at 2024-01-01",
		},
		{
			name:     "Missing variable",
			input:    "Installing {version} with {missing}",
			vars:     map[string]string{"version": "1.21.0"},
			expected: "Installing 1.21.0 with {missing}",
		},
		{
			name:     "No variables",
			input:    "Plain text",
			vars:     map[string]string{},
			expected: "Plain text",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := interpolateString(tt.input, tt.vars)
			if result != tt.expected {
				t.Errorf("interpolateString() = %q, want %q", result, tt.expected)
			}
		})
	}
}

func TestExecutorTimeout(t *testing.T) {
	// This test verifies timeout mechanism exists, but we can't easily test
	// actual timeout without a slow action. We'll just verify the config is respected.
	config := &Config{
		Version:           1,
		Enabled:           true,
		AcknowledgedRisks: true,
		Settings: Settings{
			Timeout:    "1s", // Very short timeout
			MaxActions: 10,
		},
		Hooks: map[string][]Action{
			"pre_install": {
				{
					Action: "log_to_file",
					Params: map[string]interface{}{
						"file":   filepath.Join(t.TempDir(), "test.log"),
						"format": "test",
					},
				},
			},
		},
	}

	executor := NewExecutor(config)

	// Fast action should complete before timeout
	err := executor.Execute(PreInstall, map[string]string{})
	if err != nil {
		t.Errorf("Execute() with fast action timed out: %v", err)
	}
}

func TestInterpolateParams(t *testing.T) {
	params := map[string]interface{}{
		"string_param":  "Value: {version}",
		"number_param":  42,
		"bool_param":    true,
		"nested_string": "{hook} at {timestamp}",
	}

	vars := map[string]string{
		"version":   "1.21.0",
		"hook":      "pre_install",
		"timestamp": "2024-01-01",
	}

	result := interpolateParams(params, vars)

	// Check string interpolation
	if result["string_param"] != "Value: 1.21.0" {
		t.Errorf("interpolateParams() string_param = %v, want 'Value: 1.21.0'", result["string_param"])
	}

	// Check nested string interpolation
	if result["nested_string"] != "pre_install at 2024-01-01" {
		t.Errorf("interpolateParams() nested_string = %v, want 'pre_install at 2024-01-01'", result["nested_string"])
	}

	// Check non-string params unchanged
	if result["number_param"] != 42 {
		t.Errorf("interpolateParams() number_param = %v, want 42", result["number_param"])
	}
	if result["bool_param"] != true {
		t.Errorf("interpolateParams() bool_param = %v, want true", result["bool_param"])
	}
}

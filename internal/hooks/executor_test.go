package hooks

import (
	"net"
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/go-nv/goenv/internal/utils"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestNewExecutor(t *testing.T) {
	config := &Config{
		Version:           1,
		Enabled:           true,
		AcknowledgedRisks: true,
		Settings: Settings{
			Timeout:    "5s",
			MaxActions: 10,
		},
	}

	executor := NewExecutor(config)
	require.NotNil(t, executor, "NewExecutor() returned nil")
	assert.Equal(t, config, executor.config, "NewExecutor() config not set correctly")
	assert.NotNil(t, executor.registry, "NewExecutor() registry is nil")
}

func TestExecutorExecute_Disabled(t *testing.T) {
	config := &Config{
		Version:           1,
		Enabled:           false, // Disabled
		AcknowledgedRisks: false,
	}

	executor := NewExecutor(config)
	err := executor.Execute(PreInstall, map[string]string{"version": "1.21.0"})
	assert.NoError(t, err, "Execute() with disabled hooks returned error")
}

func TestExecutorExecute_NoHooks(t *testing.T) {
	config := &Config{
		Version:           1,
		Enabled:           true,
		AcknowledgedRisks: true,
		Settings: Settings{
			Timeout:    "5s",
			MaxActions: 10,
		},
		Hooks: map[string][]Action{}, // No hooks configured
	}

	executor := NewExecutor(config)
	err := executor.Execute(PreInstall, map[string]string{"version": "1.21.0"})
	assert.NoError(t, err, "Execute() with no hooks returned error")
}

func TestExecutorExecute_LogToFile(t *testing.T) {
	tmpDir := t.TempDir()
	logFile := filepath.Join(tmpDir, "test.log")

	config := &Config{
		Version:           1,
		Enabled:           true,
		AcknowledgedRisks: true,
		Settings: Settings{
			Timeout:         "5s",
			MaxActions:      10,
			ContinueOnError: true,
		},
		Hooks: map[string][]Action{
			"pre_install": {
				{
					Action: "log_to_file",
					Params: map[string]interface{}{
						"file":   logFile,
						"format": "Installing {version} at {timestamp}",
					},
				},
			},
		},
	}

	executor := NewExecutor(config)
	vars := map[string]string{
		"version":   "1.21.0",
		"hook":      "pre_install",
		"timestamp": "2024-01-01T00:00:00Z",
	}

	err := executor.Execute(PreInstall, vars)
	require.NoError(t, err, "Execute() unexpected error")

	// Verify log file was created and contains interpolated values
	content, err := os.ReadFile(logFile)
	require.NoError(t, err, "Failed to read log file")

	contentStr := string(content)
	assert.Contains(t, contentStr, "Installing 1.21.0", "Log file doesn't contain interpolated version %v", contentStr)
	// Note: timestamp will be auto-generated by log_to_file action, not from template
	assert.Contains(t, contentStr, "at", "Log file doesn't contain expected format %v", contentStr)
}

func TestExecutorExecute_UnknownAction(t *testing.T) {
	config := &Config{
		Version:           1,
		Enabled:           true,
		AcknowledgedRisks: true,
		Settings: Settings{
			Timeout:         "5s",
			MaxActions:      10,
			ContinueOnError: false,
		},
		Hooks: map[string][]Action{
			"pre_install": {
				{
					Action: "unknown_action",
					Params: map[string]interface{}{},
				},
			},
		},
	}

	executor := NewExecutor(config)
	err := executor.Execute(PreInstall, map[string]string{})
	assert.Error(t, err, "Execute() with unknown action expected error, got nil")
	assert.Contains(t, err.Error(), "unknown action", "Execute() error message = %v", err)
}

func TestExecutorExecute_ContinueOnError(t *testing.T) {
	tmpDir := t.TempDir()
	logFile := filepath.Join(tmpDir, "test.log")

	config := &Config{
		Version:           1,
		Enabled:           true,
		AcknowledgedRisks: true,
		Settings: Settings{
			Timeout:         "5s",
			MaxActions:      10,
			ContinueOnError: true,
		},
		Hooks: map[string][]Action{
			"pre_install": {
				{
					Action: "log_to_file",
					Params: map[string]interface{}{
						// Missing required 'file' parameter - will fail
						"format": "test",
					},
				},
				{
					Action: "log_to_file",
					Params: map[string]interface{}{
						"file":   logFile,
						"format": "Second action executed",
					},
				},
			},
		},
	}

	executor := NewExecutor(config)
	err := executor.Execute(PreInstall, map[string]string{})

	// Should NOT error because continue_on_error is true
	assert.NoError(t, err, "Execute() with continue_on_error=true returned error")

	// Verify second action still executed
	content, err := os.ReadFile(logFile)
	require.NoError(t, err, "Failed to read log file")
	assert.Contains(t, string(content), "Second action executed", "Second action was not executed despite continue_on_error=true")
}

func TestExecutorExecute_StopOnError(t *testing.T) {
	tmpDir := t.TempDir()
	logFile := filepath.Join(tmpDir, "test.log")

	config := &Config{
		Version:           1,
		Enabled:           true,
		AcknowledgedRisks: true,
		Settings: Settings{
			Timeout:         "5s",
			MaxActions:      10,
			ContinueOnError: false, // Stop on first error
		},
		Hooks: map[string][]Action{
			"pre_install": {
				{
					Action: "log_to_file",
					Params: map[string]interface{}{
						// Missing required 'file' parameter - will fail
						"format": "test",
					},
				},
				{
					Action: "log_to_file",
					Params: map[string]interface{}{
						"file":   logFile,
						"format": "This should not execute",
					},
				},
			},
		},
	}

	executor := NewExecutor(config)
	err := executor.Execute(PreInstall, map[string]string{})

	// Should error because continue_on_error is false
	assert.Error(t, err, "Execute() with continue_on_error=false expected error, got nil")

	// Verify second action did NOT execute
	if utils.PathExists(logFile) {
		t.Error("Second action was executed despite continue_on_error=false")
	}
}

func TestExecutorTestExecute_Disabled(t *testing.T) {
	config := &Config{
		Version:           1,
		Enabled:           false,
		AcknowledgedRisks: false,
	}

	executor := NewExecutor(config)
	results, err := executor.TestExecute(PreInstall, map[string]string{"version": "1.21.0"})
	assert.NoError(t, err, "TestExecute() unexpected error")
	assert.False(t, len(results) != 1 || !strings.Contains(results[0], "disabled"), "TestExecute() with disabled hooks =")
}

func TestExecutorTestExecute_NoHooks(t *testing.T) {
	config := &Config{
		Version:           1,
		Enabled:           true,
		AcknowledgedRisks: true,
		Settings: Settings{
			Timeout:    "5s",
			MaxActions: 10,
		},
		Hooks: map[string][]Action{},
	}

	executor := NewExecutor(config)
	results, err := executor.TestExecute(PreInstall, map[string]string{})
	assert.NoError(t, err, "TestExecute() unexpected error")
	assert.False(t, len(results) != 1 || !strings.Contains(results[0], "No hooks configured"), "TestExecute() with no hooks =")
}

func TestExecutorTestExecute_ValidActions(t *testing.T) {
	config := &Config{
		Version:           1,
		Enabled:           true,
		AcknowledgedRisks: true,
		Settings: Settings{
			Timeout:    "5s",
			MaxActions: 10,
		},
		Hooks: map[string][]Action{
			"pre_install": {
				{
					Action: "log_to_file",
					Params: map[string]interface{}{
						"file":   "/tmp/test.log",
						"format": "Installing {version}",
					},
				},
			},
		},
	}

	executor := NewExecutor(config)
	results, err := executor.TestExecute(PreInstall, map[string]string{"version": "1.21.0"})
	assert.NoError(t, err, "TestExecute() unexpected error")

	// Should show success and interpolated values
	require.NotEmpty(t, results, "TestExecute() returned no results")

	foundSuccess := false
	foundInterpolation := false
	for _, result := range results {
		if strings.Contains(result, "✓") || strings.Contains(result, "log_to_file") {
			foundSuccess = true
		}
		if strings.Contains(result, "Installing 1.21.0") {
			foundInterpolation = true
		}
	}

	assert.True(t, foundSuccess, "TestExecute() results missing success indicator")
	assert.True(t, foundInterpolation, "TestExecute() results missing interpolated values")
}

func TestExecutorTestExecute_InvalidAction(t *testing.T) {
	config := &Config{
		Version:           1,
		Enabled:           true,
		AcknowledgedRisks: true,
		Settings: Settings{
			Timeout:    "5s",
			MaxActions: 10,
		},
		Hooks: map[string][]Action{
			"pre_install": {
				{
					Action: "unknown_action",
					Params: map[string]interface{}{},
				},
			},
		},
	}

	executor := NewExecutor(config)
	results, err := executor.TestExecute(PreInstall, map[string]string{})
	assert.NoError(t, err, "TestExecute() unexpected error")

	// Should show failure for unknown action
	foundError := false
	for _, result := range results {
		if strings.Contains(result, "✗") || strings.Contains(result, "unknown") {
			foundError = true
			break
		}
	}
	assert.True(t, foundError, "TestExecute() with unknown action should show error")
}

func TestTemplateInterpolation(t *testing.T) {
	tests := []struct {
		name     string
		input    string
		vars     map[string]string
		expected string
	}{
		{
			name:     "Single variable",
			input:    "Installing {version}",
			vars:     map[string]string{"version": "1.21.0"},
			expected: "Installing 1.21.0",
		},
		{
			name:     "Multiple variables",
			input:    "{hook} for {version} at {timestamp}",
			vars:     map[string]string{"hook": "pre_install", "version": "1.21.0", "timestamp": "2024-01-01"},
			expected: "pre_install for 1.21.0 at 2024-01-01",
		},
		{
			name:     "Missing variable",
			input:    "Installing {version} with {missing}",
			vars:     map[string]string{"version": "1.21.0"},
			expected: "Installing 1.21.0 with {missing}",
		},
		{
			name:     "No variables",
			input:    "Plain text",
			vars:     map[string]string{},
			expected: "Plain text",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := interpolateString(tt.input, tt.vars)
			assert.Equal(t, tt.expected, result, "interpolateString() =")
		})
	}
}

func TestExecutorTimeout(t *testing.T) {
	// This test verifies timeout mechanism exists, but we can't easily test
	// actual timeout without a slow action. We'll just verify the config is respected.
	config := &Config{
		Version:           1,
		Enabled:           true,
		AcknowledgedRisks: true,
		Settings: Settings{
			Timeout:    "1s", // Very short timeout
			MaxActions: 10,
		},
		Hooks: map[string][]Action{
			"pre_install": {
				{
					Action: "log_to_file",
					Params: map[string]interface{}{
						"file":   filepath.Join(t.TempDir(), "test.log"),
						"format": "test",
					},
				},
			},
		},
	}

	executor := NewExecutor(config)

	// Fast action should complete before timeout
	err := executor.Execute(PreInstall, map[string]string{})
	assert.NoError(t, err, "Execute() with fast action timed out")
}

func TestInterpolateParams(t *testing.T) {
	params := map[string]interface{}{
		"string_param":  "Value: {version}",
		"number_param":  42,
		"bool_param":    true,
		"nested_string": "{hook} at {timestamp}",
	}

	vars := map[string]string{
		"version":   "1.21.0",
		"hook":      "pre_install",
		"timestamp": "2024-01-01",
	}

	result := interpolateParams(params, vars)

	// Check string interpolation
	assert.Equal(t, "Value: 1.21.0", result["string_param"], "interpolateParams() string_param =")

	// Check nested string interpolation
	assert.Equal(t, "pre_install at 2024-01-01", result["nested_string"], "interpolateParams() nested_string =")

	// Check non-string params unchanged
	assert.Equal(t, 42, result["number_param"], "interpolateParams() number_param =")
	assert.Equal(t, true, result["bool_param"], "interpolateParams() bool_param =")
}

// TestValidateURL_PrivateIPRanges tests SSRF protection against various private IP ranges
func TestValidateURL_PrivateIPRanges(t *testing.T) {
	tests := []struct {
		name          string
		url           string
		allowInternal bool
		shouldError   bool
		errorContains string
	}{
		// RFC1918 private ranges
		{
			name:          "RFC1918 10.0.0.0/8",
			url:           "http://10.0.0.1",
			allowInternal: false,
			shouldError:   true,
			errorContains: "internal/private IP",
		},
		{
			name:          "RFC1918 172.16.0.0/12",
			url:           "http://172.16.0.1",
			allowInternal: false,
			shouldError:   true,
			errorContains: "internal/private IP",
		},
		{
			name:          "RFC1918 192.168.0.0/16",
			url:           "http://192.168.1.1",
			allowInternal: false,
			shouldError:   true,
			errorContains: "internal/private IP",
		},

		// RFC6598 CGNAT range (carrier-grade NAT)
		{
			name:          "RFC6598 CGNAT 100.64.0.0/10 - start",
			url:           "http://100.64.0.1",
			allowInternal: false,
			shouldError:   true,
			errorContains: "internal/private IP",
		},
		{
			name:          "RFC6598 CGNAT 100.64.0.0/10 - middle",
			url:           "http://100.80.0.1",
			allowInternal: false,
			shouldError:   true,
			errorContains: "internal/private IP",
		},
		{
			name:          "RFC6598 CGNAT 100.64.0.0/10 - end",
			url:           "http://100.127.255.254",
			allowInternal: false,
			shouldError:   true,
			errorContains: "internal/private IP",
		},

		// Loopback
		{
			name:          "Loopback 127.0.0.1",
			url:           "http://127.0.0.1",
			allowInternal: false,
			shouldError:   true,
			errorContains: "internal/private IP",
		},
		{
			name:          "Loopback 127.0.0.0/8 range",
			url:           "http://127.255.255.255",
			allowInternal: false,
			shouldError:   true,
			errorContains: "internal/private IP",
		},

		// Link-local
		{
			name:          "Link-local 169.254.0.0/16",
			url:           "http://169.254.1.1",
			allowInternal: false,
			shouldError:   true,
			errorContains: "internal/private IP",
		},

		// Public IPs should be allowed
		{
			name:          "Public IP 8.8.8.8",
			url:           "http://8.8.8.8",
			allowInternal: false,
			shouldError:   false,
		},
		{
			name:          "Public IP 1.1.1.1",
			url:           "http://1.1.1.1",
			allowInternal: false,
			shouldError:   false,
		},

		// Allow internal when flag is set
		{
			name:          "Private IP allowed with flag",
			url:           "http://192.168.1.1",
			allowInternal: true,
			shouldError:   false,
		},
		{
			name:          "CGNAT allowed with flag",
			url:           "http://100.64.0.1",
			allowInternal: true,
			shouldError:   false,
		},

		// HTTPS enforcement
		{
			name:          "HTTP not allowed by default",
			url:           "http://example.com",
			allowInternal: false,
			shouldError:   true,
			errorContains: "HTTP URLs are not allowed",
		},

		// Valid HTTPS URLs
		{
			name:          "HTTPS allowed",
			url:           "https://example.com",
			allowInternal: false,
			shouldError:   false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// For HTTP URLs, we need to set allowHTTP to true to test IP blocking
			allowHTTP := strings.HasPrefix(tt.url, "http://") && !strings.Contains(tt.errorContains, "HTTP URLs")

			err := ValidateURL(tt.url, allowHTTP, tt.allowInternal)

			if tt.shouldError {
				if err == nil {
					t.Errorf("ValidateURL(%q) expected error, got nil", tt.url)
				} else if tt.errorContains != "" && !strings.Contains(err.Error(), tt.errorContains) {
					t.Errorf("ValidateURL(%q) error = %v, should contain %q", tt.url, err, tt.errorContains)
				}
			} else {
				assert.NoError(t, err, "ValidateURL() unexpected error")
			}
		})
	}
}

// TestValidateURL_EdgeCases tests edge cases and boundary conditions
func TestValidateURL_EdgeCases(t *testing.T) {
	tests := []struct {
		name        string
		url         string
		shouldError bool
		description string
	}{
		{
			name:        "Empty URL",
			url:         "",
			shouldError: true,
			description: "Empty URL should be rejected",
		},
		{
			name:        "Invalid scheme",
			url:         "ftp://example.com",
			shouldError: true,
			description: "Non-HTTP(S) schemes should be rejected",
		},
		{
			name:        "URL without scheme",
			url:         "example.com",
			shouldError: true,
			description: "URLs without scheme should be rejected",
		},
		{
			name:        "CGNAT boundary - just before range",
			url:         "http://100.63.255.255",
			shouldError: false,
			description: "100.63.255.255 is outside CGNAT range (public)",
		},
		{
			name:        "CGNAT boundary - just after range",
			url:         "http://100.128.0.0",
			shouldError: false,
			description: "100.128.0.0 is outside CGNAT range (public)",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			err := ValidateURL(tt.url, true, false)

			if tt.shouldError && err == nil {
				t.Errorf("%s: expected error, got nil", tt.description)
			} else if !tt.shouldError && err != nil {
				t.Errorf("%s: unexpected error: %v", tt.description, err)
			}
		})
	}
}

// TestValidateURL_StrictDNS tests the strict DNS mode for SSRF protection
func TestValidateURL_StrictDNS(t *testing.T) {
	tests := []struct {
		name        string
		url         string
		strictDNS   bool
		shouldError bool
		description string
	}{
		{
			name:        "Valid public domain - non-strict",
			url:         "https://go.dev",
			strictDNS:   false,
			shouldError: false,
			description: "Public domain should work in non-strict mode",
		},
		{
			name:        "Valid public domain - strict",
			url:         "https://go.dev",
			strictDNS:   true,
			shouldError: false,
			description: "Public domain should work in strict mode",
		},
		{
			name:        "Invalid domain with DNS failure - non-strict",
			url:         "https://thisdoesnotexistandneverwill123456789.example",
			strictDNS:   false,
			shouldError: false,
			description: "DNS failure without suspicious patterns should be allowed in non-strict mode",
		},
		{
			name:        "Invalid domain with DNS failure - strict",
			url:         "https://thisdoesnotexistandneverwill123456789.example",
			strictDNS:   true,
			shouldError: true,
			description: "DNS failure should be rejected in strict mode",
		},
		{
			name:        "Localhost pattern - non-strict",
			url:         "https://my-localhost.example",
			strictDNS:   false,
			shouldError: true,
			description: "Localhost pattern should be caught even in non-strict mode",
		},
		{
			name:        "Internal pattern - non-strict",
			url:         "https://api.internal",
			strictDNS:   false,
			shouldError: true,
			description: "Internal pattern should be caught even in non-strict mode",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Use HTTPS only, disallow internal IPs, vary strict DNS mode
			err := ValidateURLWithStrictDNS(tt.url, false, false, tt.strictDNS)

			if tt.shouldError && err == nil {
				t.Errorf("%s: expected error, got nil", tt.description)
			} else if !tt.shouldError && err != nil {
				t.Errorf("%s: unexpected error: %v", tt.description, err)
			}
		})
	}
}

// TestIsPrivateIP tests the isPrivateIP helper function directly
func TestIsPrivateIP(t *testing.T) {
	tests := []struct {
		name      string
		ip        string
		isPrivate bool
	}{
		// RFC1918
		{"10.0.0.0", "10.0.0.0", true},
		{"10.255.255.255", "10.255.255.255", true},
		{"172.16.0.0", "172.16.0.0", true},
		{"172.31.255.255", "172.31.255.255", true},
		{"192.168.0.0", "192.168.0.0", true},
		{"192.168.255.255", "192.168.255.255", true},

		// RFC6598 CGNAT
		{"100.64.0.0", "100.64.0.0", true},
		{"100.64.0.1", "100.64.0.1", true},
		{"100.127.255.254", "100.127.255.254", true},
		{"100.127.255.255", "100.127.255.255", true},

		// Boundaries (should be public)
		{"100.63.255.255", "100.63.255.255", false},
		{"100.128.0.0", "100.128.0.0", false},

		// Loopback
		{"127.0.0.1", "127.0.0.1", true},
		{"127.255.255.255", "127.255.255.255", true},

		// Link-local
		{"169.254.0.1", "169.254.0.1", true},
		{"169.254.255.254", "169.254.255.254", true},

		// Public
		{"8.8.8.8", "8.8.8.8", false},
		{"1.1.1.1", "1.1.1.1", false},
		{"9.9.9.9", "9.9.9.9", false},

		// IPv6 loopback
		{"::1", "::1", true},

		// IPv6 link-local
		{"fe80::1", "fe80::1", true},

		// IPv6 unique local
		{"fc00::1", "fc00::1", true},
		{"fd00::1", "fd00::1", true},

		// IPv6 public
		{"2001:4860:4860::8888", "2001:4860:4860::8888", false},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ip := net.ParseIP(tt.ip)
			require.NotNil(t, ip, "Failed to parse IP")

			result := isPrivateIP(ip)
			assert.Equal(t, tt.isPrivate, result, "isPrivateIP() = %v", tt.ip)
		})
	}
}

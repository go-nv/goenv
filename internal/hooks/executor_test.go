package hooks

import (
	"net"
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/go-nv/goenv/internal/utils"
)

func TestNewExecutor(t *testing.T) {
	config := &Config{
		Version:           1,
		Enabled:           true,
		AcknowledgedRisks: true,
		Settings: Settings{
			Timeout:    "5s",
			MaxActions: 10,
		},
	}

	executor := NewExecutor(config)
	if executor == nil {
		t.Fatal("NewExecutor() returned nil")
	}
	if executor.config != config {
		t.Error("NewExecutor() config not set correctly")
	}
	if executor.registry == nil {
		t.Error("NewExecutor() registry is nil")
	}
}

func TestExecutorExecute_Disabled(t *testing.T) {
	config := &Config{
		Version:           1,
		Enabled:           false, // Disabled
		AcknowledgedRisks: false,
	}

	executor := NewExecutor(config)
	err := executor.Execute(PreInstall, map[string]string{"version": "1.21.0"})
	if err != nil {
		t.Errorf("Execute() with disabled hooks returned error: %v", err)
	}
}

func TestExecutorExecute_NoHooks(t *testing.T) {
	config := &Config{
		Version:           1,
		Enabled:           true,
		AcknowledgedRisks: true,
		Settings: Settings{
			Timeout:    "5s",
			MaxActions: 10,
		},
		Hooks: map[string][]Action{}, // No hooks configured
	}

	executor := NewExecutor(config)
	err := executor.Execute(PreInstall, map[string]string{"version": "1.21.0"})
	if err != nil {
		t.Errorf("Execute() with no hooks returned error: %v", err)
	}
}

func TestExecutorExecute_LogToFile(t *testing.T) {
	tmpDir := t.TempDir()
	logFile := filepath.Join(tmpDir, "test.log")

	config := &Config{
		Version:           1,
		Enabled:           true,
		AcknowledgedRisks: true,
		Settings: Settings{
			Timeout:         "5s",
			MaxActions:      10,
			ContinueOnError: true,
		},
		Hooks: map[string][]Action{
			"pre_install": {
				{
					Action: "log_to_file",
					Params: map[string]interface{}{
						"file":   logFile,
						"format": "Installing {version} at {timestamp}",
					},
				},
			},
		},
	}

	executor := NewExecutor(config)
	vars := map[string]string{
		"version":   "1.21.0",
		"hook":      "pre_install",
		"timestamp": "2024-01-01T00:00:00Z",
	}

	err := executor.Execute(PreInstall, vars)
	if err != nil {
		t.Fatalf("Execute() unexpected error: %v", err)
	}

	// Verify log file was created and contains interpolated values
	content, err := os.ReadFile(logFile)
	if err != nil {
		t.Fatalf("Failed to read log file: %v", err)
	}

	contentStr := string(content)
	if !strings.Contains(contentStr, "Installing 1.21.0") {
		t.Errorf("Log file doesn't contain interpolated version, got: %s", contentStr)
	}
	// Note: timestamp will be auto-generated by log_to_file action, not from template
	if !strings.Contains(contentStr, "at") {
		t.Errorf("Log file doesn't contain expected format, got: %s", contentStr)
	}
}

func TestExecutorExecute_UnknownAction(t *testing.T) {
	config := &Config{
		Version:           1,
		Enabled:           true,
		AcknowledgedRisks: true,
		Settings: Settings{
			Timeout:         "5s",
			MaxActions:      10,
			ContinueOnError: false,
		},
		Hooks: map[string][]Action{
			"pre_install": {
				{
					Action: "unknown_action",
					Params: map[string]interface{}{},
				},
			},
		},
	}

	executor := NewExecutor(config)
	err := executor.Execute(PreInstall, map[string]string{})
	if err == nil {
		t.Error("Execute() with unknown action expected error, got nil")
	}
	if !strings.Contains(err.Error(), "unknown action") {
		t.Errorf("Execute() error message = %v, want to contain 'unknown action'", err)
	}
}

func TestExecutorExecute_ContinueOnError(t *testing.T) {
	tmpDir := t.TempDir()
	logFile := filepath.Join(tmpDir, "test.log")

	config := &Config{
		Version:           1,
		Enabled:           true,
		AcknowledgedRisks: true,
		Settings: Settings{
			Timeout:         "5s",
			MaxActions:      10,
			ContinueOnError: true,
		},
		Hooks: map[string][]Action{
			"pre_install": {
				{
					Action: "log_to_file",
					Params: map[string]interface{}{
						// Missing required 'file' parameter - will fail
						"format": "test",
					},
				},
				{
					Action: "log_to_file",
					Params: map[string]interface{}{
						"file":   logFile,
						"format": "Second action executed",
					},
				},
			},
		},
	}

	executor := NewExecutor(config)
	err := executor.Execute(PreInstall, map[string]string{})

	// Should NOT error because continue_on_error is true
	if err != nil {
		t.Errorf("Execute() with continue_on_error=true returned error: %v", err)
	}

	// Verify second action still executed
	content, err := os.ReadFile(logFile)
	if err != nil {
		t.Fatalf("Failed to read log file: %v", err)
	}
	if !strings.Contains(string(content), "Second action executed") {
		t.Error("Second action was not executed despite continue_on_error=true")
	}
}

func TestExecutorExecute_StopOnError(t *testing.T) {
	tmpDir := t.TempDir()
	logFile := filepath.Join(tmpDir, "test.log")

	config := &Config{
		Version:           1,
		Enabled:           true,
		AcknowledgedRisks: true,
		Settings: Settings{
			Timeout:         "5s",
			MaxActions:      10,
			ContinueOnError: false, // Stop on first error
		},
		Hooks: map[string][]Action{
			"pre_install": {
				{
					Action: "log_to_file",
					Params: map[string]interface{}{
						// Missing required 'file' parameter - will fail
						"format": "test",
					},
				},
				{
					Action: "log_to_file",
					Params: map[string]interface{}{
						"file":   logFile,
						"format": "This should not execute",
					},
				},
			},
		},
	}

	executor := NewExecutor(config)
	err := executor.Execute(PreInstall, map[string]string{})

	// Should error because continue_on_error is false
	if err == nil {
		t.Error("Execute() with continue_on_error=false expected error, got nil")
	}

	// Verify second action did NOT execute
	if utils.PathExists(logFile) {
		t.Error("Second action was executed despite continue_on_error=false")
	}
}

func TestExecutorTestExecute_Disabled(t *testing.T) {
	config := &Config{
		Version:           1,
		Enabled:           false,
		AcknowledgedRisks: false,
	}

	executor := NewExecutor(config)
	results, err := executor.TestExecute(PreInstall, map[string]string{"version": "1.21.0"})
	if err != nil {
		t.Errorf("TestExecute() unexpected error: %v", err)
	}
	if len(results) != 1 || !strings.Contains(results[0], "disabled") {
		t.Errorf("TestExecute() with disabled hooks = %v, want disabled message", results)
	}
}

func TestExecutorTestExecute_NoHooks(t *testing.T) {
	config := &Config{
		Version:           1,
		Enabled:           true,
		AcknowledgedRisks: true,
		Settings: Settings{
			Timeout:    "5s",
			MaxActions: 10,
		},
		Hooks: map[string][]Action{},
	}

	executor := NewExecutor(config)
	results, err := executor.TestExecute(PreInstall, map[string]string{})
	if err != nil {
		t.Errorf("TestExecute() unexpected error: %v", err)
	}
	if len(results) != 1 || !strings.Contains(results[0], "No hooks configured") {
		t.Errorf("TestExecute() with no hooks = %v, want no hooks message", results)
	}
}

func TestExecutorTestExecute_ValidActions(t *testing.T) {
	config := &Config{
		Version:           1,
		Enabled:           true,
		AcknowledgedRisks: true,
		Settings: Settings{
			Timeout:    "5s",
			MaxActions: 10,
		},
		Hooks: map[string][]Action{
			"pre_install": {
				{
					Action: "log_to_file",
					Params: map[string]interface{}{
						"file":   "/tmp/test.log",
						"format": "Installing {version}",
					},
				},
			},
		},
	}

	executor := NewExecutor(config)
	results, err := executor.TestExecute(PreInstall, map[string]string{"version": "1.21.0"})
	if err != nil {
		t.Errorf("TestExecute() unexpected error: %v", err)
	}

	// Should show success and interpolated values
	if len(results) == 0 {
		t.Fatal("TestExecute() returned no results")
	}

	foundSuccess := false
	foundInterpolation := false
	for _, result := range results {
		if strings.Contains(result, "✓") || strings.Contains(result, "log_to_file") {
			foundSuccess = true
		}
		if strings.Contains(result, "Installing 1.21.0") {
			foundInterpolation = true
		}
	}

	if !foundSuccess {
		t.Errorf("TestExecute() results missing success indicator: %v", results)
	}
	if !foundInterpolation {
		t.Errorf("TestExecute() results missing interpolated values: %v", results)
	}
}

func TestExecutorTestExecute_InvalidAction(t *testing.T) {
	config := &Config{
		Version:           1,
		Enabled:           true,
		AcknowledgedRisks: true,
		Settings: Settings{
			Timeout:    "5s",
			MaxActions: 10,
		},
		Hooks: map[string][]Action{
			"pre_install": {
				{
					Action: "unknown_action",
					Params: map[string]interface{}{},
				},
			},
		},
	}

	executor := NewExecutor(config)
	results, err := executor.TestExecute(PreInstall, map[string]string{})
	if err != nil {
		t.Errorf("TestExecute() unexpected error: %v", err)
	}

	// Should show failure for unknown action
	foundError := false
	for _, result := range results {
		if strings.Contains(result, "✗") || strings.Contains(result, "unknown") {
			foundError = true
			break
		}
	}
	if !foundError {
		t.Errorf("TestExecute() with unknown action should show error, got: %v", results)
	}
}

func TestTemplateInterpolation(t *testing.T) {
	tests := []struct {
		name     string
		input    string
		vars     map[string]string
		expected string
	}{
		{
			name:     "Single variable",
			input:    "Installing {version}",
			vars:     map[string]string{"version": "1.21.0"},
			expected: "Installing 1.21.0",
		},
		{
			name:     "Multiple variables",
			input:    "{hook} for {version} at {timestamp}",
			vars:     map[string]string{"hook": "pre_install", "version": "1.21.0", "timestamp": "2024-01-01"},
			expected: "pre_install for 1.21.0 at 2024-01-01",
		},
		{
			name:     "Missing variable",
			input:    "Installing {version} with {missing}",
			vars:     map[string]string{"version": "1.21.0"},
			expected: "Installing 1.21.0 with {missing}",
		},
		{
			name:     "No variables",
			input:    "Plain text",
			vars:     map[string]string{},
			expected: "Plain text",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := interpolateString(tt.input, tt.vars)
			if result != tt.expected {
				t.Errorf("interpolateString() = %q, want %q", result, tt.expected)
			}
		})
	}
}

func TestExecutorTimeout(t *testing.T) {
	// This test verifies timeout mechanism exists, but we can't easily test
	// actual timeout without a slow action. We'll just verify the config is respected.
	config := &Config{
		Version:           1,
		Enabled:           true,
		AcknowledgedRisks: true,
		Settings: Settings{
			Timeout:    "1s", // Very short timeout
			MaxActions: 10,
		},
		Hooks: map[string][]Action{
			"pre_install": {
				{
					Action: "log_to_file",
					Params: map[string]interface{}{
						"file":   filepath.Join(t.TempDir(), "test.log"),
						"format": "test",
					},
				},
			},
		},
	}

	executor := NewExecutor(config)

	// Fast action should complete before timeout
	err := executor.Execute(PreInstall, map[string]string{})
	if err != nil {
		t.Errorf("Execute() with fast action timed out: %v", err)
	}
}

func TestInterpolateParams(t *testing.T) {
	params := map[string]interface{}{
		"string_param":  "Value: {version}",
		"number_param":  42,
		"bool_param":    true,
		"nested_string": "{hook} at {timestamp}",
	}

	vars := map[string]string{
		"version":   "1.21.0",
		"hook":      "pre_install",
		"timestamp": "2024-01-01",
	}

	result := interpolateParams(params, vars)

	// Check string interpolation
	if result["string_param"] != "Value: 1.21.0" {
		t.Errorf("interpolateParams() string_param = %v, want 'Value: 1.21.0'", result["string_param"])
	}

	// Check nested string interpolation
	if result["nested_string"] != "pre_install at 2024-01-01" {
		t.Errorf("interpolateParams() nested_string = %v, want 'pre_install at 2024-01-01'", result["nested_string"])
	}

	// Check non-string params unchanged
	if result["number_param"] != 42 {
		t.Errorf("interpolateParams() number_param = %v, want 42", result["number_param"])
	}
	if result["bool_param"] != true {
		t.Errorf("interpolateParams() bool_param = %v, want true", result["bool_param"])
	}
}

// TestValidateURL_PrivateIPRanges tests SSRF protection against various private IP ranges
func TestValidateURL_PrivateIPRanges(t *testing.T) {
	tests := []struct {
		name          string
		url           string
		allowInternal bool
		shouldError   bool
		errorContains string
	}{
		// RFC1918 private ranges
		{
			name:          "RFC1918 10.0.0.0/8",
			url:           "http://10.0.0.1",
			allowInternal: false,
			shouldError:   true,
			errorContains: "internal/private IP",
		},
		{
			name:          "RFC1918 172.16.0.0/12",
			url:           "http://172.16.0.1",
			allowInternal: false,
			shouldError:   true,
			errorContains: "internal/private IP",
		},
		{
			name:          "RFC1918 192.168.0.0/16",
			url:           "http://192.168.1.1",
			allowInternal: false,
			shouldError:   true,
			errorContains: "internal/private IP",
		},

		// RFC6598 CGNAT range (carrier-grade NAT)
		{
			name:          "RFC6598 CGNAT 100.64.0.0/10 - start",
			url:           "http://100.64.0.1",
			allowInternal: false,
			shouldError:   true,
			errorContains: "internal/private IP",
		},
		{
			name:          "RFC6598 CGNAT 100.64.0.0/10 - middle",
			url:           "http://100.80.0.1",
			allowInternal: false,
			shouldError:   true,
			errorContains: "internal/private IP",
		},
		{
			name:          "RFC6598 CGNAT 100.64.0.0/10 - end",
			url:           "http://100.127.255.254",
			allowInternal: false,
			shouldError:   true,
			errorContains: "internal/private IP",
		},

		// Loopback
		{
			name:          "Loopback 127.0.0.1",
			url:           "http://127.0.0.1",
			allowInternal: false,
			shouldError:   true,
			errorContains: "internal/private IP",
		},
		{
			name:          "Loopback 127.0.0.0/8 range",
			url:           "http://127.255.255.255",
			allowInternal: false,
			shouldError:   true,
			errorContains: "internal/private IP",
		},

		// Link-local
		{
			name:          "Link-local 169.254.0.0/16",
			url:           "http://169.254.1.1",
			allowInternal: false,
			shouldError:   true,
			errorContains: "internal/private IP",
		},

		// Public IPs should be allowed
		{
			name:          "Public IP 8.8.8.8",
			url:           "http://8.8.8.8",
			allowInternal: false,
			shouldError:   false,
		},
		{
			name:          "Public IP 1.1.1.1",
			url:           "http://1.1.1.1",
			allowInternal: false,
			shouldError:   false,
		},

		// Allow internal when flag is set
		{
			name:          "Private IP allowed with flag",
			url:           "http://192.168.1.1",
			allowInternal: true,
			shouldError:   false,
		},
		{
			name:          "CGNAT allowed with flag",
			url:           "http://100.64.0.1",
			allowInternal: true,
			shouldError:   false,
		},

		// HTTPS enforcement
		{
			name:          "HTTP not allowed by default",
			url:           "http://example.com",
			allowInternal: false,
			shouldError:   true,
			errorContains: "HTTP URLs are not allowed",
		},

		// Valid HTTPS URLs
		{
			name:          "HTTPS allowed",
			url:           "https://example.com",
			allowInternal: false,
			shouldError:   false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// For HTTP URLs, we need to set allowHTTP to true to test IP blocking
			allowHTTP := strings.HasPrefix(tt.url, "http://") && !strings.Contains(tt.errorContains, "HTTP URLs")

			err := ValidateURL(tt.url, allowHTTP, tt.allowInternal)

			if tt.shouldError {
				if err == nil {
					t.Errorf("ValidateURL(%q) expected error, got nil", tt.url)
				} else if tt.errorContains != "" && !strings.Contains(err.Error(), tt.errorContains) {
					t.Errorf("ValidateURL(%q) error = %v, should contain %q", tt.url, err, tt.errorContains)
				}
			} else {
				if err != nil {
					t.Errorf("ValidateURL(%q) unexpected error: %v", tt.url, err)
				}
			}
		})
	}
}

// TestValidateURL_EdgeCases tests edge cases and boundary conditions
func TestValidateURL_EdgeCases(t *testing.T) {
	tests := []struct {
		name        string
		url         string
		shouldError bool
		description string
	}{
		{
			name:        "Empty URL",
			url:         "",
			shouldError: true,
			description: "Empty URL should be rejected",
		},
		{
			name:        "Invalid scheme",
			url:         "ftp://example.com",
			shouldError: true,
			description: "Non-HTTP(S) schemes should be rejected",
		},
		{
			name:        "URL without scheme",
			url:         "example.com",
			shouldError: true,
			description: "URLs without scheme should be rejected",
		},
		{
			name:        "CGNAT boundary - just before range",
			url:         "http://100.63.255.255",
			shouldError: false,
			description: "100.63.255.255 is outside CGNAT range (public)",
		},
		{
			name:        "CGNAT boundary - just after range",
			url:         "http://100.128.0.0",
			shouldError: false,
			description: "100.128.0.0 is outside CGNAT range (public)",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			err := ValidateURL(tt.url, true, false)

			if tt.shouldError && err == nil {
				t.Errorf("%s: expected error, got nil", tt.description)
			} else if !tt.shouldError && err != nil {
				t.Errorf("%s: unexpected error: %v", tt.description, err)
			}
		})
	}
}

// TestValidateURL_StrictDNS tests the strict DNS mode for SSRF protection
func TestValidateURL_StrictDNS(t *testing.T) {
	tests := []struct {
		name        string
		url         string
		strictDNS   bool
		shouldError bool
		description string
	}{
		{
			name:        "Valid public domain - non-strict",
			url:         "https://go.dev",
			strictDNS:   false,
			shouldError: false,
			description: "Public domain should work in non-strict mode",
		},
		{
			name:        "Valid public domain - strict",
			url:         "https://go.dev",
			strictDNS:   true,
			shouldError: false,
			description: "Public domain should work in strict mode",
		},
		{
			name:        "Invalid domain with DNS failure - non-strict",
			url:         "https://thisdoesnotexistandneverwill123456789.example",
			strictDNS:   false,
			shouldError: false,
			description: "DNS failure without suspicious patterns should be allowed in non-strict mode",
		},
		{
			name:        "Invalid domain with DNS failure - strict",
			url:         "https://thisdoesnotexistandneverwill123456789.example",
			strictDNS:   true,
			shouldError: true,
			description: "DNS failure should be rejected in strict mode",
		},
		{
			name:        "Localhost pattern - non-strict",
			url:         "https://my-localhost.example",
			strictDNS:   false,
			shouldError: true,
			description: "Localhost pattern should be caught even in non-strict mode",
		},
		{
			name:        "Internal pattern - non-strict",
			url:         "https://api.internal",
			strictDNS:   false,
			shouldError: true,
			description: "Internal pattern should be caught even in non-strict mode",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Use HTTPS only, disallow internal IPs, vary strict DNS mode
			err := ValidateURLWithStrictDNS(tt.url, false, false, tt.strictDNS)

			if tt.shouldError && err == nil {
				t.Errorf("%s: expected error, got nil", tt.description)
			} else if !tt.shouldError && err != nil {
				t.Errorf("%s: unexpected error: %v", tt.description, err)
			}
		})
	}
}

// TestIsPrivateIP tests the isPrivateIP helper function directly
func TestIsPrivateIP(t *testing.T) {
	tests := []struct {
		name      string
		ip        string
		isPrivate bool
	}{
		// RFC1918
		{"10.0.0.0", "10.0.0.0", true},
		{"10.255.255.255", "10.255.255.255", true},
		{"172.16.0.0", "172.16.0.0", true},
		{"172.31.255.255", "172.31.255.255", true},
		{"192.168.0.0", "192.168.0.0", true},
		{"192.168.255.255", "192.168.255.255", true},

		// RFC6598 CGNAT
		{"100.64.0.0", "100.64.0.0", true},
		{"100.64.0.1", "100.64.0.1", true},
		{"100.127.255.254", "100.127.255.254", true},
		{"100.127.255.255", "100.127.255.255", true},

		// Boundaries (should be public)
		{"100.63.255.255", "100.63.255.255", false},
		{"100.128.0.0", "100.128.0.0", false},

		// Loopback
		{"127.0.0.1", "127.0.0.1", true},
		{"127.255.255.255", "127.255.255.255", true},

		// Link-local
		{"169.254.0.1", "169.254.0.1", true},
		{"169.254.255.254", "169.254.255.254", true},

		// Public
		{"8.8.8.8", "8.8.8.8", false},
		{"1.1.1.1", "1.1.1.1", false},
		{"9.9.9.9", "9.9.9.9", false},

		// IPv6 loopback
		{"::1", "::1", true},

		// IPv6 link-local
		{"fe80::1", "fe80::1", true},

		// IPv6 unique local
		{"fc00::1", "fc00::1", true},
		{"fd00::1", "fd00::1", true},

		// IPv6 public
		{"2001:4860:4860::8888", "2001:4860:4860::8888", false},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ip := net.ParseIP(tt.ip)
			if ip == nil {
				t.Fatalf("Failed to parse IP: %s", tt.ip)
			}

			result := isPrivateIP(ip)
			if result != tt.isPrivate {
				t.Errorf("isPrivateIP(%s) = %v, want %v", tt.ip, result, tt.isPrivate)
			}
		})
	}
}
